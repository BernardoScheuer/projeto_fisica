<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Projeto de Física: Lançamento de Projétil</title>
  <style>
    :root {
      --bg: #0f172a;         /* slate-900 */
      --panel: #111827;      /* gray-900 */
      --soft: #1f2937;       /* gray-800 */
      --text: #e5e7eb;       /* gray-200 */
      --muted: #9ca3af;      /* gray-400 */
      --accent: #22c55e;     /* green-500 */
      --accent-2: #38bdf8;   /* sky-400 */
      --accent-3: #fbbf24;   /* amber-400 */
      --danger: #ef4444;     /* red-500 */
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 15% 0%, #0b122e 0%, var(--bg) 55%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    header {
      padding: 18px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      border-bottom: 1px solid #1f2937;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0));
    }
    header h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.3px;
      font-weight: 700;
    }
    header .badge {
      color: #0f172a;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 12px;
    }

    .container {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      padding: 16px;
      height: calc(100% - 70px);
    }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
      border: 1px solid #1f2937;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .panel h2 {
      font-size: 16px; margin: 0; padding: 14px 16px; border-bottom: 1px solid #1f2937; background: #0f172a88;
    }

    .controls { padding: 14px 14px 6px; display: grid; gap: 12px; }
    .row { display: grid; grid-template-columns: 1fr 110px; gap: 10px; align-items: center; }
    label { font-size: 13px; color: var(--muted); }
    input[type="number"], input[type="range"], select {
      width: 100%; background: var(--soft); border: 1px solid #374151; color: var(--text);
      border-radius: 10px; padding: 10px 12px; outline: none;
    }
    input[type="range"] { padding: 0; height: 32px; }

    .switch { display: flex; align-items: center; gap: 10px; font-size: 13px; color: var(--muted); }
    .switch input { transform: scale(1.1); }

    .buttons { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; padding: 8px 14px 14px; }
    .btn {
      border-radius: 12px; border: 1px solid #334155; padding: 10px 12px; cursor: pointer; font-weight: 700;
      background: linear-gradient(180deg, #1e293b, #111827); color: var(--text); transition: 120ms transform ease, 120ms box-shadow ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 8px 16px rgba(0,0,0,0.35); }
    .btn.primary { background: linear-gradient(90deg, var(--accent), var(--accent-2)); color: #0a0f1f; border-color: transparent; }
    .btn.warn { background: linear-gradient(90deg, #fb923c, #f97316); color: #0a0f1f; border-color: transparent; }

    .calc {
      padding: 14px;
      border-top: 1px dashed #263041;
      background: #0b1220;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      color: #d1d5db;
      overflow: auto;
      max-height: 46vh;
      white-space: pre-wrap;
    }

    .canvas-wrap { position: relative; display: grid; grid-template-rows: 1fr auto; height: 100%; }
    canvas { width: 100%; height: 100%; background: radial-gradient(1200px 600px at 70% -10%, #142046 0%, #0a1026 60%); border-bottom-left-radius: 16px; border-bottom-right-radius: 16px; }

    .legend {
      display: flex; flex-wrap: wrap; gap: 10px; padding: 10px 14px; border-top: 1px solid #1f2937; background: #0f172a88; font-size: 12px; color: var(--muted);
    }

    .chip { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: #0b1220; border: 1px solid #1f2937; }
    .dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; }

    @media (max-width: 1024px) {
      .container { grid-template-columns: 1fr; height: auto; }
      .panel { min-height: 360px; }
      .calc { max-height: 30vh; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Projeto de Física — Lançamento de Projétil (interativo)</h1>
    <span class="badge">1º–3º ano • Cinemática</span>
  </header>

  <div class="container">
    <!-- Painel esquerdo: controles + cálculos -->
    <section class="panel" style="min-height: 540px;">
      <h2>Parâmetros</h2>
      <div class="controls">
        <div class="row">
          <label for="v0">Velocidade inicial v₀ (m/s)</label>
          <input id="v0" type="number" value="20" step="0.1" min="0" />
        </div>
        <div class="row">
          <label for="angulo">Ângulo (°)</label>
          <input id="angulo" type="number" value="45" step="1" min="0" max="90" />
        </div>
        <div class="row">
          <label for="h0">Altura inicial h₀ (m)</label>
          <input id="h0" type="number" value="0" step="0.1" min="0" />
        </div>
        <div class="row">
          <label for="g">Gravidade g (m/s²)</label>
          <input id="g" type="number" value="9.8" step="0.1" min="0.1" />
        </div>
        <div class="row">
          <label for="speed">Velocidade da animação</label>
          <input id="speed" type="range" min="0.25" max="4" step="0.25" value="1" />
        </div>
        <div class="switch"><input type="checkbox" id="trail" checked /> <label for="trail">Mostrar trilha</label></div>
        <div class="switch"><input type="checkbox" id="vectors" /> <label for="vectors">Mostrar vetores (v e g)</label></div>
      </div>

      <div class="buttons">
        <button class="btn primary" id="btnStart">Iniciar</button>
        <button class="btn" id="btnPause">Pausar</button>
        <button class="btn warn" id="btnReset">Resetar</button>
      </div>

      <h2>Fórmulas e Cálculos</h2>
      <div class="calc" id="calcBox"></div>
    </section>

    <!-- Painel direito: canvas + legenda -->
    <section class="panel canvas-wrap">
      <div style="padding: 10px 14px; border-bottom: 1px solid #1f2937; display:flex; align-items:center; justify-content:space-between;">
        <div style="font-size:14px; color:var(--muted)">Área de simulação (ajuste automático de escala)</div>
        <div id="hud" style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:12px; color:#cbd5e1"></div>
      </div>
      <canvas id="sim" width="1100" height="560"></canvas>
      <div class="legend">
        <span class="chip"><span class="dot" style="background: var(--accent)"></span>Trajetória</span>
        <span class="chip"><span class="dot" style="background: var(--accent-2)"></span>Velocidade</span>
        <span class="chip"><span class="dot" style="background: var(--danger)"></span>Gravidade</span>
        <span class="chip"><span class="dot" style="background: var(--accent-3)"></span>Alcance</span>
      </div>
    </section>
  </div>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const v0El = $('#v0');
    const angEl = $('#angulo');
    const h0El = $('#h0');
    const gEl = $('#g');
    const speedEl = $('#speed');
    const trailEl = $('#trail');
    const vectorsEl = $('#vectors');
    const calcBox = $('#calcBox');
    const hud = $('#hud');

    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');

    let state = {
      running: false,
      t: 0,
      dtBase: 1/60,
      path: [],
      lastPoint: null,
      world: { width: 50, height: 20, margin: 20, scale: 10 },
      params: {}
    };

    function toRad(deg) { return deg * Math.PI / 180; }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function computeParams() {
      const v0 = Math.max(0, parseFloat(v0El.value || '0'));
      const ang = clamp(parseFloat(angEl.value || '0'), 0, 90);
      const h0 = Math.max(0, parseFloat(h0El.value || '0'));
      const g = Math.max(0.01, parseFloat(gEl.value || '9.8'));

      const rad = toRad(ang);
      const v0x = v0 * Math.cos(rad);
      const v0y = v0 * Math.sin(rad);

      const disc = v0y*v0y + 2*g*h0; // discriminante para achar T
      const T = (v0y + Math.sqrt(disc)) / g; // raiz positiva
      const R = v0x * T; // alcance
      const hMax = h0 + (v0y*v0y) / (2*g);
      const tUp = v0y / g;

      return { v0, ang, rad, h0, g, v0x, v0y, T, R, hMax, tUp };
    }

    function fitWorld(p) {
      // Dimensões previsíveis do movimento para ajustar a escala do canvas
      const minW = 10; const minH = 5;
      const w = Math.max(minW, p.R * 1.1 + 2);
      const h = Math.max(minH, p.hMax * 1.1 + 2);
      const margin = 30;
      const sx = (canvas.width - margin*2) / (w || minW);
      const sy = (canvas.height - margin*2) / (h || minH);
      const scale = Math.min(sx, sy);
      state.world = { width: w, height: h, margin, scale };
    }

    function worldToScreen(x, y) {
      const { margin, scale } = state.world;
      const px = margin + x * scale;
      const py = canvas.height - margin - y * scale; // y=0 no chão
      return [px, py];
    }

    function kinematicsAt(t, p) {
      const x = p.v0x * t;
      const y = p.h0 + p.v0y * t - 0.5 * p.g * t * t;
      const vy = p.v0y - p.g * t;
      const vx = p.v0x;
      return { x, y, vx, vy };
    }

    function format(n) {
      return (Math.round(n * 100) / 100).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
    }

    function updateCalcPanel(p) {
      const lines = [];
      lines.push('Decomposição de v₀:');
      lines.push(`v₀x = v₀·cos(θ) = ${format(p.v0)}·cos(${format(p.ang)}) = ${format(p.v0x)} m/s`);
      lines.push(`v₀y = v₀·sin(θ) = ${format(p.v0)}·sin(${format(p.ang)}) = ${format(p.v0y)} m/s`);
      lines.push('');
      lines.push('Tempo de voo (resolvendo h₀ + v₀y·T − (g/2)·T² = 0):');
      const disc = p.v0y*p.v0y + 2*p.g*p.h0;
      lines.push(`Δ = v₀y² + 2·g·h₀ = ${format(p.v0y*p.v0y)} + 2·${format(p.g)}·${format(p.h0)} = ${format(disc)}`);
      lines.push(`T = (v₀y + √Δ) / g = (${format(p.v0y)} + √${format(disc)}) / ${format(p.g)} = ${format(p.T)} s`);
      lines.push('');
      lines.push('Alcance horizontal:');
      lines.push(`R = v₀x·T = ${format(p.v0x)}·${format(p.T)} = ${format(p.R)} m`);
      lines.push('');
      lines.push('Altura máxima:');
      lines.push(`h_max = h₀ + v₀y²/(2g) = ${format(p.h0)} + ${format(p.v0y*p.v0y)}/(2·${format(p.g)}) = ${format(p.hMax)} m`);
      lines.push('');
      lines.push('Equações paramétricas do movimento:');
      lines.push('x(t) = v₀x·t');
      lines.push('y(t) = h₀ + v₀y·t − (g/2)·t²');
      lines.push('');
      lines.push(`Tempo de subida: t_sub = v₀y/g = ${format(p.v0y)}/${format(p.g)} = ${format(p.tUp)} s`);
      calcBox.textContent = lines.join('\n');
    }

    function drawGrid() {
      const { margin, scale } = state.world;
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.07)';

      // grade em metros (a cada 1 m) — espaçamento mínimo de 16 px
      const stepMeters = Math.max(1, Math.ceil(16 / scale));

      // linhas verticais
      for (let xm = 0; xm <= state.world.width; xm += stepMeters) {
        const [x] = worldToScreen(xm, 0);
        ctx.beginPath();
        ctx.moveTo(x, margin);
        ctx.lineTo(x, canvas.height - margin);
        ctx.stroke();
      }

      // linhas horizontais
      for (let ym = 0; ym <= state.world.height; ym += stepMeters) {
        const [, y] = worldToScreen(0, ym);
        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(canvas.width - margin, y);
        ctx.stroke();
      }

      // solo
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const y0 = worldToScreen(0, 0)[1];
      ctx.moveTo(margin, y0);
      ctx.lineTo(canvas.width - margin, y0);
      ctx.stroke();

      ctx.restore();
    }

    function drawArrow(x, y, vx, vy, color, scalePix=1) {
      const len = Math.sqrt(vx*vx + vy*vy);
      if (len < 1e-6) return;
      const ux = vx/len, uy = vy/len;
      const size = 10; // tamanho da ponta em px

      ctx.save();
      ctx.strokeStyle = color; ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + vx*scalePix, y + vy*scalePix);
      ctx.stroke();

      // ponta
      const px = x + vx*scalePix, py = y + vy*scalePix;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px - ux*size - uy*size*0.6, py - uy*size + ux*size*0.6);
      ctx.lineTo(px - ux*size + uy*size*0.6, py - uy*size - ux*size*0.6);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawScene() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();

      const p = state.params;
      const { margin, scale } = state.world;

      // alcance previsto marcador
      ctx.save();
      ctx.strokeStyle = '#fbbf24';
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 2;
      const [xr, yr] = worldToScreen(p.R, 0);
      ctx.beginPath(); ctx.moveTo(xr, margin); ctx.lineTo(xr, canvas.height - margin); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#fbbf24';
      ctx.font = '12px ui-monospace, monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`R ≈ ${format(p.R)} m`, xr, canvas.height - margin - 6);
      ctx.restore();

      // trilha
      if (trailEl.checked && state.path.length > 1) {
        ctx.save();
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        const [x0, y0] = worldToScreen(state.path[0].x, state.path[0].y);
        ctx.moveTo(x0, y0);
        for (let i = 1; i < state.path.length; i++) {
          const [xi, yi] = worldToScreen(state.path[i].x, state.path[i].y);
          ctx.lineTo(xi, yi);
        }
        ctx.stroke();
        ctx.restore();
      }

      // projétil
      const last = state.lastPoint || { x: 0, y: p.h0, vx: p.v0x, vy: p.v0y };
      const [bx, by] = worldToScreen(last.x, last.y);

      // brilho
      const grd = ctx.createRadialGradient(bx, by, 2, bx, by, 26);
      grd.addColorStop(0, 'rgba(56,189,248,0.9)');
      grd.addColorStop(1, 'rgba(56,189,248,0.0)');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(bx, by, 26, 0, Math.PI*2); ctx.fill();

      // corpo
      ctx.fillStyle = '#38bdf8';
      ctx.beginPath(); ctx.arc(bx, by, 6, 0, Math.PI*2); ctx.fill();

      // vetores
      if (vectorsEl.checked) {
        // velocidade (escala visual, não é 1:1)
        const scaleVel = 6; // px por (m/s)
        drawArrow(bx, by, last.vx, -last.vy, '#38bdf8', 1/scaleVel * 2); // invertendo y
        // gravidade (fixo para baixo)
        drawArrow(bx, by, 0, 40, '#ef4444', 1); // seta para baixo
      }

      // HUD
      hud.innerText = `t = ${format(state.t)} s  |  x = ${format(last.x)} m, y = ${format(Math.max(0,last.y))} m  |  v = (${format(last.vx)} , ${format(last.vy)}) m/s`;
    }

    function resetSim(keepScale=false) {
      state.running = false; state.t = 0; state.path = [];
      state.params = computeParams();
      if (!keepScale) fitWorld(state.params);
      state.lastPoint = { x: 0, y: state.params.h0, vx: state.params.v0x, vy: state.params.v0y };
      updateCalcPanel(state.params);
      drawScene();
    }

    function step() {
      if (!state.running) return;
      const speedMul = parseFloat(speedEl.value || '1');
      const p = state.params;
      const dt = state.dtBase * speedMul;
      state.t += dt;

      const k = kinematicsAt(state.t, p);

      if (k.y <= 0 && state.t > 0) {
        // chegou ao chão — travar em y=0 e parar
        state.running = false;
        const kEnd = { ...k, y: 0 };
        state.lastPoint = kEnd;
        state.path.push(kEnd);
        drawScene();
        return;
      }

      state.lastPoint = k;
      state.path.push(k);
      drawScene();
      requestAnimationFrame(step);
    }

    // Eventos
    $('#btnStart').addEventListener('click', () => {
      // recalcula tudo e inicia
      resetSim(true);
      state.running = true;
      requestAnimationFrame(step);
    });

    $('#btnPause').addEventListener('click', () => {
      state.running = !state.running;
      if (state.running) requestAnimationFrame(step);
    });

    $('#btnReset').addEventListener('click', () => resetSim(false));

    // atualizar cálculos ao mudar parâmetros
    ;[v0El, angEl, h0El, gEl].forEach(el => {
      el.addEventListener('input', () => {
        const p = computeParams();
        updateCalcPanel(p);
      });
    });

    // Inicializar
    resetSim(false);
  </script>
</body>
</html>
